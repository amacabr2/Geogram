/ * axios v0.17.1 | (c) 2017 par Matt Zabriskie * /
! function (e, t) {"object" == typeof exporte && "objet" == typeof module? module.exports = t (): "fonction" == typeof définit && define.amd? define ([], t): " object "== typeof exportations? exports.axios = t (): e.axios = t ()} (this, function () {return fonction (e) {fonction t (r) {if (n [r]) return n [r] .exports; var o = n [r] = {exportations: {}, id: r, chargé:! 1}; return e [r] .call (o.exports, o, o.exports, t ), o.loaded =! 0, o.exports} var n = {}; renvoyer tm = e, tc = n, tp = "", t (0)} ([fonction (e, t, n) {e .exports = n (1)}, fonction (e, t, n) {"use strict"; fonction r (e) {var t = nouveau s (e), n = i (s.prototype.request, t) ; return o.extend (n, s.prototype, t), o.extend (n, t), n) var o = n (2), i = n (3), s = n (5), u = n (6), a = r (u); a.Axios = s, a.create = fonction (e) {renvoyer r (o.merge (u, e))}, a.Annuler = n (23), a.CancelToken = n (24), a.isCancel = n (20), a.all = fonction (e) {return Promise.all (e)}, a.spread = n (25), e.exports = a, e.exports.default = a}, fonction (e, t, n) {"use strict"; fonction r (e) {return "[tableau d'objets]" === R.call (e)} function o (e) {return "[objet ArrayBuffer]" === R.call (e)} fonction i (e) {return "undefined"! = type de FormData && e instanceof FormData} fonction s (e) {var t; t = "undefined"! = typeof ArrayBuffer && ArrayBuffer.isView? ArrayBuffer.isView (e): e && e.buffer && e.buffer instanceof ArrayBuffer} fonction u (e) {return "chaîne" == typeof e} fonction a (e) {return " number "== typeof e} fonction c (e) {return" undefined "== typeof e} fonction f (e) {return null! == e &&" objet "== typeof e} fonction p (e) {return" [object Date] "=== R.call (e)} fonction d (e) {return" [objet Fichier] "=== R.call (e)} fonction l (e) {return" [objet Blob] "=== R.appel (e)} fonction h (e) {return "[fonction objet]" === R.call (e)} fonction m (e) {return f (e) && h (e.pipe)} fonction y (e ) {return "undefined"! = typeof URLSearchParams && e instanceof URLSearchParams} fonction w (e) {return e.replace (/ ^ \ s * /, ""). replace (/ \ s * $ /, "")} fonction g () {return ("undefined" == typeof navigateur || "ReactNative"! == navigator.product) && ("undefined"! = type de fenêtre && "undefined"! = type de document)} function v (e, t) { if (null! == e && "undefined"! = typeof e) if ("objet"! = type de e && (e = [e]), r (e)) pour (var n = 0, o = e.length; n <o; n ++) t.call (null, e [n], n, e), sinon pour (var i dans e) Object.prototype.hasOwnProperty.call (e, i) && t.call (null, e [ i], i, e)} fonction x () {fonction e (e, n) {"objet" == typeof t [n] && "object "== typeof e? t [n] = x (t [n], e): t [n] = e} pour (var t = {}, n = 0, r = arguments.length; n <r ; n ++) v (arguments [n], e); return t} fonction b (e, t, n) {return v (t, fonction (t, r) {n && "fonction" == typeof t? e [r ] = E (t, n): e [r] = t}), e} var E = n (3), C = n (4), R = Object.prototype.toString; e.exports = {isArray: r, isArrayBuffer: o, isBuffer: C, isFormData: i, isArrayBufferView: s, isString: u, isNumber: a, isObject: f, isUndéfini: c, isDate: p, isFichier: d, isBlob: l, isFonction: h, isStream: m, isURLSearchParams: y, estStandardBrowserEnv: g, pourEach: v, fusionne: x, étend: b, coupe: w}}, fonction (e, t) {"use strict"; e.exports = function (e, t) {return function () {pour (var n = new Tableau (arguments.length), r = 0; r <n.length; r ++) n [r] = arguments [r]; return e.apply (t, n)}}}, fonction (e, t) {fonction n (e) {retour !! e.constructeur && "fonction" == typeof e.constructor.isBuffer && e.constructor.isBuffer (e)} fonction r (e) {return "fonction" == typeof e.readFloatLE && "fonction" == typeof e.slice && n (e.slice (0,0))} / *!
* Déterminer si un objet est un tampon
*
* @author Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
    * @license MIT
* /
e.exports = fonction (e) {return null! = e && (n (e) || r (e) || !! e._isBuffer)}}, fonction (e, t, n) {"use strict"; fonction r (e) {this.defaults = e, this.interceptors = {demande: nouvelle s, réponse: nouvelle s}} var o = n (6), i = n (2), s = n (17), u = n (18); r.prototype.request = fonction (e) {"chaîne" == typeof e && (e = i.merge ({url: arguments [0]}, arguments [1])), e = i.merge (o, this.defaults, {méthode: "obtenir"}, e), e.method = e.method.toLowCase (); var t = [u, void 0], n = Promise.resolve (e ) (pour cette requête .interceptors.forEach (fonction (e) {t.unshift (e.fulfilled, e.rejected)}), this.interceptors.response.forEach (fonction (e) {t.push (e .fulfilled, e.rejected)}); t.length;) n = n.then (t.shift (), t.shift ()); renvoie n}, i.forEach (["delete", "get" , "head", "options"], function (e) {r.prototype [e] = fonction (t, n) {renvoyer cette.request (i.merge (n || {}, {méthode: e, url :t}))}}), i.forEach (["post", "put", "patch"], fonction (e) {r.prototype [e] = fonction (t, n, r) {return this. request (i.merge (r || {}, {méthode: e, url: t, donnée: n}))}}), e.exports = r}, fonction (e, t, n) {"use strict "; la fonction r (e, t) {! i.isUndefined (e) && i.isUndefined (e [" Content-Type "]) && (e [" Content-Type "] = t)} function o () {var e: return "undefined"! = type de XMLHttpRequest? e = n (8): "undefined"! = type de processus && (e = n (8)), e} var i = n (2), s = n (7) , u = {"Content-Type": "application / x-www-format-urlencoded"}, a = {adaptateur: o (), transformRequest: [fonction (e, t) {return s (t, "Content- Tapez "), i.isFormData (e) || i.isArrayBuffer (e) || i.isBuffer (e) || i.isStream (e) || i.isFichier (e) || i.isBlob (e) ? e: i.isArrayBufferView (e)? e.buffer: i.isURLSearchParams (e)? (r (t, "application / x-www-format-urlencoded; charset = utf-8 "), e.toString ()): i.isObject (e)? (r (t," application / json; jeu de caractères = utf-8 "), JSON.stringify (e)): e}], transformResponse: [fonction (e) {if ("chaîne" == typeof e) try {e = JSON.parse (e)} catch (e) {} return e} ], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, validateStatus: fonction (e) {return e> = 200 && e <300}}; a.headers = {common: {Accepter: "application / json, text / plain, * / *"}}, i.forEach (["supprimer", "obtenir", "head"], fonction (e) {a.headers [e ] = {}}), i.forEach (["post", "put", "patch"], la fonction (e) {a.headers [e] = i.merge (u)}), e.exports = a}, fonction (e, t, n) {"use strict"; var r = n (2); e.exports = fonction (e, t) {r.forEach (e, fonction (n, r) {r ! == t && r.toUpperCase () === t.toUpperCase () && (e [t] = n, supprimer e [r])}}}}, fonction (e, t, n) {"use strict"; var r = n (2), o = n (9 ), i = n (12), s = n (13), u = n (14), a = n (10), c = "indéfini"! = typeof window && window.btoa && window.btoa.bind (fenêtre) || n (15); e.exports = function (e) {return new Promesse (fonction (t, f)) {var p = e.data, d = e.headers; r.isFormData (p) && delete d ["Contenu- Tapez "]; var l = nouveau XMLHttpRequest, h =" onreadystatechange ", m =! 1; if (" non défini "== typeof window ||! Window.XDomainRequest ||" avecCredentials "dans l || u (e.url ) || (l = nouvelle fenêtre.XDomaineRequête, h = "onload", m =! 0, l.onprogress = fonction () {}, l.ontimeout = fonction () {}), e.auth) {var y = e.auth.username || "", w = e.auth.password || ""; d.Authorization = "De base" + c (y + ":" + w)} if (l.open (e.method .toUpperCase (), i (e.url, e.params, e.paramsSerializer) ,!0), l.timeout = e.timeout, l [h] = fonction () {if (l && (4 === l.readyState || m) && (0! == l.status || l.responseURL && 0 = == l.responseURL.indexOf ("file:"))) {var n = "getAllResponseHeaders" dans l? s (l.getAllResponseHeaders ()): null, r = e.responseType && "text"! == e.responseType ? l.response: l.responseText, i = {data: r, statut: 1223 === l.status? 204: l.status, statusText: 1223 === l.status? "Aucun contenu": l.statusText , en-têtes: n, config: e, requête: l}; o (t, f, i), l = null}}, l.erreur = function () {f (a ("Erreur réseau", e, null, l)), l = null}, l.ontimeout = fonction () {f (a ("timeout de" + e.timeout + "ms dépassé", e, "ECONNABORTED", l)), l = null}, r .isStandardBrowserEnv ()) {var g = n (16), v = (e.avecCredentials || u (e.url)) && e.xsrfCookieName? g.read (e.xsrfCookieName): void 0; v && (d [e .xsrfHeaderName] = v)} if ("setRequestHeader "dans l && r.forEach (d, fonction (e, t) {" undefined "== typeof p &&" type-de-contenu "=== t.toLowCase ()? delete d [t]: l.setRequestHeader (t, e )}), e.withCredentials && (l.withCredentials =! 0), e.responseType) try {l.responseType = e.responseType} catch (t) {if ("json"! == e.responseType) lancer t} "function" == typeof e.onDownloadProgress && l.addEventListener ("progression", e.onDownloadProgress), "function" == typeof e.onUploadProgress && l.upload && l.upload.addEventListener ("progression", e.onUploadProgress), e.cancelToken && e. cancelToken.promise.then (fonction (e) {l && (l.abort (), f (e), l = null)}), void 0 === p && (p = null), l.send (p)} }}}, fonction (e, t, n) {"use strict"; var r = n (10); e.exports = fonction (e, t, n) {var o = n.config.validateStatus; n.status && o &&! o (n.status)? t (r ("Demande échouée avec le code d'état" + n.status, n.config, null, n requête, n)): e (n)}}, la fonction (e, t, n) {"use strict"; var r = n (11); e.exports = fonction (e, t, n, o, i) {var s = new Erreur (e); return r (s, t , n, o, i)}}, fonction (e, t) {"use strict"; e.exports = fonction (e, t, n, r, o) {return e.config = t, n && (e. code = n), e.request = r, e.response = o, e}}, fonction (e, t, n) {"use strict"; fonction r (e) {return encodeURIComponent (e) .replace (/ % 40 / gi, "@"). Remplacer (/% 3A / gi, ":"). Remplacer (/% 24 / g, "$"). Remplacer (/% 2C / gi, ","). (/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var o = n (2); e.exports = function (e, t, n) {if (! t) renvoie e; var i; si (n) i = n (t); sinon if (o.isURLSearchParams (t)) i = t.toString (); {var s = []; o.forEach (t, fonction (e, t) {null! == e && "undefined"! = typeof e && (o.isArray (e) && (t + = "[]"), o.isArray (e) || (e = [e]), o.forEach (e, fonction (e ) {o.isDate (e)? e = e.toISOString (): o.isObjet (e) && (e = JSON.stringifie (e)), s.push (r (t) + "=" + r ( e))}))}), i = s.join ("&")} retour i && (e + = (e.indexOf ("?") === - 1? "?": "&") + i ), e}}, fonction (e, t, n) {"use strict"; var r = n (2), o = ["âge", "autorisation", "longueur du contenu", "type de contenu" , "etag", "expires", "from", "hôte", "if-modified-since", "si-non-modifié-depuis", "dernier-modifié", "emplacement", "max-forwards", " proxy-authorization "," referer "," réessayer après "," user-agent "]; e.exports = fonction (e) {var t, n, i, s = {};return e? (r.forEach (e.split ("\ n"), fonction (e) {if (i = e.indexOf (":"), t = r.trim (e.substr (0, i) ) .toLowerCase (), n = r.trim (e.substr (i + 1)), t) {if (s [t] && o.indexOf (t)> = 0) return; "set-cookie" == = t? s [t] = (s [t]? s [t]: []). concat ([n]): s [t] = s [t]? s [t] + "," + n : n}}), s): s}}, fonction (e, t, n) {"use strict"; var r = n (2); e.exports = r.isStandardBrowserEnv ()? function () {fonction e (e) {var t = e; renvoie n && (o.setAttribute ("href", t), t = o.href), o.setAttribute ("href", t), {href: o.href, protocole : o.protocol? o.protocol.replace (/: $ /, ""): "", hôte: o.host, recherche: o.search? o.search.replace (/ ^ \? /, "") : "", hash: o.hash? o.hash.replace (/ ^ # /, ""): "", nom d'hôte: o.hostname, port: o.port, chemin d'accès: "/" === o. pathname.charAt (0)? o.pathname: "/" + o.pathname}} var t,n = / (msie | trident) /i.test (navigator.userAgent), o = document.createElement ("a"); retourne t = e (window.location.href), fonction (n) {var o = r .isString (n)? e (n): n; return o.protocol === t.protocole && o.host === t.hôte}} (): function () {return function () {return! 0}} ()}, function (e, t) {"use strict"; fonction n () {this.message = "La chaîne contient un caractère non valide"} function r (e) {for (var t, r, i = String ( e), s = "", u = 0, a = o; i.charAt (0 | u) || (a = "=", u% 1); s + = a.charAt (63 & t >> 8-u % 1 * 8)) {if (r = i.charCodeAt (u + = 75), r> 255) lancer nouveau n; t = t << 8 | r} retourner s} var o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 + / ="; n.prototype = new Erreur, n.prototype.code = 5, n.prototype.name = "InvalidCharacterError", e.exports = r}, fonction (e, t, n) {"use strict"; var r = n (2); e.exports = r.isStandardBrowserEnv ()? function () {return {écriture: fonction (e, t, n, o, i, s) {var u = []; u.push (e + "=" + encoderURIComponent (t)), r. isNumber (n) && u.push ("expires =" + nouvelle Date (n) .toGMTString ()), r.isString (o) && u.push ("path =" + o), r.isString (i) && u. push ("domain =" + i), s ===! 0 && u.push ("sécurisé"), document.cookie = u.join (";")}, lire: function (e) {var t = document. cookie.match (new RegExp ("(^ |; \\ s *) (" + e + ") = ([^;] *)")); return t? décodeURIComponent (t [3]): null}, supprimer : function (e) {this.write (e, "", Date.now () - 864e5)}}} (): function () {return {écriture: function () {}, lit: function () {return null}, remove: function () {}}} ()}, fonction (e, t, n) {"use strict"; fonction r () {this.handlers = []} var o = n (2); r.prototype.use = function (e, t) {return this.handlers.push ({rempli: e, rejeté: t}), this.handlers.length-1}, r.prototype.eject = fonction (e) {this.handlers [e] && (this.handlers [e] = null)}, r.prototype.forEach = fonction (e) {o. forEach (this.handlers, fonction (t) {null! == t && e (t)})}, e.exports = r}, fonction (e, t, n) {"use strict"; fonction r (e) { e.cancelToken && e.cancelToken.throwIfRequested ()} var o = n (2), i = n (19), s = n (20), u = n (6), a = n (21), c = n ( 22); e.exports = fonction (e) {r (e), e.baseURL &&! A (e.url) && (e.url = c (e.baseURL, e.url)), e.headers = e .headers || {}, e.data = i (e.data, e.headers, e.transformRequest), e.headers = o.merge (e.headers.common || {}, e.headers [e. méthode] || {}, e.headers || {}), o.forEach (["supprimer", "obtenir", "tête", "publier", "mettre", "patcher", "commun"], function (t) {delete e.headers [t]}); var t = e.adapter || u.adapter; retourne t (e) .then (fonction (t) {return r (e), t.data = je (t.data, t.en-têtes, e.transformResponse), t}, la fonction (t) {return s (t) || (r (e), t && t.response && (t.response.data = i (t.response.data, t.response. headers, e.transformResponse))), Promise.reject (t)})}}, fonction (e, t, n) {"use strict"; var r = n (2); e.exports = fonction (e, t, n) {return r.forEach (n, fonction (n) {e = n (e, t)}), e}}, fonction (e, t) {"use strict"; e.exports = fonction ( e) {return! (! e ||! e .__ CANCEL __)}}, fonction (e, t) {"use strict"; e.exports = fonction (e) {return / ^ ([az] [az \ d \ + \ - \.] *:)? \ / \ // i.test (e)}}, fonction (e, t) {"use strict"; e.exports = fonction (e, t) {return t ? e.replace (/ \ / + $ /, "") + "/" + t.replace (/ ^ \ / + /, ""): e}}, fonction (e, t) {"use strict" ; fonction n (e) {this.message = e} n.prototype.toString = function () {return "Annuler" + (this.message? ":" + this.message: "")}, n.prototype.__CANCEL __ =! 0, e.exports = n}, fonction (e, t, n) {"use strict"; fonction r (e) {if ("fonction"! = Typeof e) lance une nouvelle erreur TypeError ("executor doit être une fonction. "); var t; this.promise = nouvelle Promesse (fonction (e) {t = e}); var n = cette; e (fonction (e) {n.reason || (n.reason = new o (e), t (n.reason))})} var o = n (23); r.prototype.throwIfRequested = fonction () {if (this.reason) lancer this.reason}, r.source = fonction () {var e, t = nouveau r (fonction (t) {e = t}); return {token: t, annuler: e}}, e.exports = r}, fonction (e, t) {"utiliser strict "; e.exports = fonction (e) {fonction de retour (t) {return e.apply (null, t)}}}])});raison))})} var o = n (23); r.prototype.throwIfRequested = fonction () {if (this.reason) jette this.reason}, r.source = fonction () {var e, t = new r (fonction (t) {e = t}); return {token: t, annuler: e}}, e.exports = r}, fonction (e, t) {"use strict"; e.exports = fonction ( e) {return function (t) {return e.apply (null, t)}}}])});raison))})} var o = n (23); r.prototype.throwIfRequested = fonction () {if (this.reason) jette this.reason}, r.source = fonction () {var e, t = new r (fonction (t) {e = t}); return {token: t, annuler: e}}, e.exports = r}, fonction (e, t) {"use strict"; e.exports = fonction ( e) {return function (t) {return e.apply (null, t)}}}])});
// # sourceMappingURL = axios.min.map